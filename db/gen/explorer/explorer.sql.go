// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: explorer.sql

package explorerdb

import (
	"context"
)

const countLikes = `-- name: CountLikes :one
SELECT COUNT(*)
FROM decisions
WHERE recipient_user_id = $1 AND liked_recipient = true
`

func (q *Queries) CountLikes(ctx context.Context, recipientUserID string) (int64, error) {
	row := q.db.QueryRow(ctx, countLikes, recipientUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDecision = `-- name: CreateDecision :exec
INSERT INTO decisions (actor_user_id, recipient_user_id, liked_recipient, created_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (actor_user_id, recipient_user_id)
    DO UPDATE SET
                  liked_recipient = EXCLUDED.liked_recipient,
                  created_at = NOW()
`

type CreateDecisionParams struct {
	ActorUserID     string
	RecipientUserID string
	LikedRecipient  bool
}

func (q *Queries) CreateDecision(ctx context.Context, arg CreateDecisionParams) error {
	_, err := q.db.Exec(ctx, createDecision, arg.ActorUserID, arg.RecipientUserID, arg.LikedRecipient)
	return err
}

const hasMutualLike = `-- name: HasMutualLike :one
SELECT EXISTS(
    SELECT 1 FROM decisions
    WHERE decisions.actor_user_id = $1 AND decisions.recipient_user_id = $2 AND decisions.liked_recipient = true
) AND EXISTS(
    SELECT 1 FROM decisions
    WHERE decisions.actor_user_id = $2 AND decisions.recipient_user_id = $1 AND decisions.liked_recipient = true
)
`

type HasMutualLikeParams struct {
	ActorUserID     string
	RecipientUserID string
}

func (q *Queries) HasMutualLike(ctx context.Context, arg HasMutualLikeParams) (*bool, error) {
	row := q.db.QueryRow(ctx, hasMutualLike, arg.ActorUserID, arg.RecipientUserID)
	var column_1 *bool
	err := row.Scan(&column_1)
	return column_1, err
}
